<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cytophage — Семейный мир</title>
  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: #020409; overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e5e5e5;
    }
    #canvas {
      display: block; width: 100vw; height: 100vh;
      background: radial-gradient(circle at center, #050814 0%, #010206 60%, #000000 100%);
      cursor: grab;
    }
    #canvas:active { cursor: grabbing; }

    .hud {
      position: fixed; left: 10px; top: 10px; padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6); border-radius: 8px; font-size: 12px;
      pointer-events: none; max-width: 360px;
    }
    .hud .row { margin-top: 3px; white-space: nowrap; }
    .hud .row span.label { display: inline-block; min-width: 110px; color: #8b949e; }
    .hud .row span.value { display: inline-block; min-width: 90px; }
    .server-row { display: flex; align-items: center; }
    .server-dot {
      width: 10px; height: 10px; border-radius: 50%; margin-right: 6px;
      background: #6e7681; box-shadow: 0 0 4px rgba(0,0,0,0.8);
    }
    .server-ok { background: #2ea043; box-shadow: 0 0 8px rgba(46,160,67,0.9); }
    .server-bad { background: #f85149; box-shadow: 0 0 8px rgba(248,81,73,0.9); }

    .right-container {
      position: fixed; right: 10px; top: 10px; display: flex; gap: 10px;
      max-height: calc(100vh - 20px);
    }
    .hud-right {
      width: 280px; padding: 8px 12px; background: rgba(0, 0, 0, 0.6);
      border-radius: 8px; font-size: 12px; max-height: 100%;
      overflow-y: auto; pointer-events: auto;
    }
    .hud-right-title {
      font-weight: 600; color: #79c0ff; margin-bottom: 4px;
      position: sticky; top: 0; background: rgba(0, 0, 0, 0.9);
      padding-bottom: 3px; z-index: 1;
    }
    .leader-row {
      margin-top: 3px; border-bottom: 1px solid rgba(110,118,129,0.3);
      padding: 3px 12px 3px 18px; cursor: pointer; position: relative;
    }
    .leader-row:last-child { border-bottom: none; }
    .leader-row:hover { background: rgba(56,139,253,0.15); }
    .row-selected { border: 1px solid #2ea043; background: rgba(46,160,67,0.25); }
    .leader-main {
      display: flex; justify-content: space-between; align-items: center;
      gap: 4px; white-space: nowrap;
    }
    .leader-name { font-weight: 500; }
    .leader-clan { color: #8b949e; margin-left: 6px; }
    .leader-info { font-size: 11px; color: #c9d1d9; white-space: nowrap; }

    #selectedBacteriumDetail {
      width: 280px; padding: 10px 12px; background: rgba(0, 0, 0, 0.6);
      border-radius: 8px; font-size: 12px; overflow-y: auto; pointer-events: auto;
      border: 1px solid rgba(46,160,67,0.5); display: none;
    }
    .detail-title { font-weight: 600; color: #2ea043; margin-bottom: 4px; }
    .detail-row {
      margin-bottom: 3px; border-bottom: 1px solid rgba(110,118,129,0.25);
      padding-bottom: 4px;
    }
    .detail-row .label {
      color: #8b949e; display: inline-block; min-width: 90px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="hud">
    <div class="row server-row">
      <div id="serverDot" class="server-dot"></div>
      <div id="serverStatusText">Сервер: нет данных</div>
    </div>
    <div class="row" id="hudRow1"></div>
    <div class="row" id="hudRow2"></div>
    <div class="row" id="hudRow3"></div>
  </div>

  <div class="right-container">
    <div id="selectedBacteriumDetail">
      <div class="detail-title">Детали выбранной бактерии</div>
      <div id="detailContent"></div>
    </div>
    <div class="hud-right">
      <div class="hud-right-title">Бактерии и кланы</div>
      <div id="leadersList"></div>
    </div>
  </div>

  <script>
    const SERVER_URL = "https://cytophage.onrender.com";

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const hudRow1 = document.getElementById("hudRow1");
    const hudRow2 = document.getElementById("hudRow2");
    const hudRow3 = document.getElementById("hudRow3");
    const serverDot = document.getElementById("serverDot");
    const serverStatusText = document.getElementById("serverStatusText");
    const leadersListEl = document.getElementById("leadersList");
    const detailPanel = document.getElementById("selectedBacteriumDetail");
    const detailContent = document.getElementById("detailContent");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    let world = { width: 8000, height: 8000 };
    let cameraX = world.width / 2;
    let cameraY = world.height / 2;
    let zoom = 0.1;

    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let cameraStartX = 0;
    let cameraStartY = 0;

    let lastStats = null;
    let lastServerOk = false;
    let serverUptimeSeconds = 0;
    let uptimeLastFetch = Date.now();

    let bacteriaRaw = [];
    let foodRaw = [];
    const renderPositions = new Map();

    let selectedBacteriumId = null;
    let lastHudInteractionTime = 0;

    function formatUptime(seconds) {
      if (!seconds || seconds < 0) return "—";
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);

      const parts = [];
      if (days > 0) parts.push(`${days}д`);
      if (hours > 0) parts.push(`${hours}ч`);
      if (minutes > 0) parts.push(`${minutes}м`);
      if (secs > 0 || parts.length === 0) parts.push(`${secs}с`);
      return parts.join(' ');
    }

    setInterval(() => {
      if (lastServerOk && serverUptimeSeconds > 0) {
        const elapsed = Math.floor((Date.now() - uptimeLastFetch) / 1000);
        const uptime = formatUptime(serverUptimeSeconds + elapsed);
        serverStatusText.innerHTML = `Сервер: работает <span style="color: #79c0ff;">· ${uptime}</span>`;
      }
    }, 1000);

    canvas.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      cameraStartX = cameraX;
      cameraStartY = cameraY;
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      cameraX = cameraStartX - dx / zoom;
      cameraY = cameraStartY - dy / zoom;
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = 1.1;
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      const worldBeforeZoomX = (mouseX - width / 2) / zoom + cameraX;
      const worldBeforeZoomY = (mouseY - height / 2) / zoom + cameraY;

      if (e.deltaY < 0) {
        zoom *= zoomFactor;
      } else {
        zoom /= zoomFactor;
      }

      zoom = Math.max(0.02, Math.min(zoom, 2));

      const worldAfterZoomX = (mouseX - width / 2) / zoom + cameraX;
      const worldAfterZoomY = (mouseY - height / 2) / zoom + cameraY;

      cameraX += worldBeforeZoomX - worldAfterZoomX;
      cameraY += worldBeforeZoomY - worldAfterZoomY;
    }, { passive: false });

    function worldToScreen(x, y) {
      const sx = (x - cameraX) * zoom + width / 2;
      const sy = (y - cameraY) * zoom + height / 2;
      return { x: sx, y: sy };
    }

    function formatAgeLabel(ageYears) {
      if (ageYears === undefined || isNaN(ageYears)) return "?";
      if (ageYears < 0.2) return "Новорождённый";
      if (ageYears < 0.5) return "Малыш";
      if (ageYears < 1.0) return "Юный";

      const yearsInt = Math.floor(ageYears);
      const lastTwo = yearsInt % 100;
      const lastDigit = yearsInt % 10;
      let word;
      if (lastTwo >= 11 && lastTwo <= 14) {
        word = "лет";
      } else if (lastDigit === 1) {
        word = "год";
      } else if (lastDigit >= 2 && lastDigit <= 4) {
        word = "года";
      } else {
        word = "лет";
      }
      return yearsInt + " " + word;
    }

    function getRenderBacteriaList() {
      const currentIds = new Set(bacteriaRaw.map(b => b.id));
      for (const id of renderPositions.keys()) {
        if (!currentIds.has(id)) {
          renderPositions.delete(id);
        }
      }

      const smoothed = [];
      const alpha = 0.025;
      const maxStep = 6;

      for (const b of bacteriaRaw) {
        let rp = renderPositions.get(b.id);
        if (!rp) {
          rp = { x: b.x, y: b.y };
          renderPositions.set(b.id, rp);
        } else {
          let dx = b.x - rp.x;
          let dy = b.y - rp.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 0;
          if (dist > maxStep) {
            const k = maxStep / dist;
            dx *= k;
            dy *= k;
          }
          rp.x += dx * alpha;
          rp.y += dy * alpha;
        }
        smoothed.push({ ...b, x: rp.x, y: rp.y });
      }
      return smoothed;
    }

    function draw() {
      const renderBacteria = getRenderBacteriaList();

      if (selectedBacteriumId !== null) {
        const target = renderBacteria.find(b => b.id === selectedBacteriumId);
        if (target) {
          const lerp = 0.03;
          cameraX += (target.x - cameraX) * lerp;
          cameraY += (target.y - cameraY) * lerp;
          const maxCamStep = 20;
          const dcx = target.x - cameraX;
          const dcy = target.y - cameraY;
          const camDist = Math.sqrt(dcx * dcx + dcy * dcy) || 0;
          if (camDist > maxCamStep) {
            const kk = maxCamStep / camDist;
            cameraX = target.x - dcx * kk;
            cameraY = target.y - dcy * kk;
          }
        } else {
          selectedBacteriumId = null;
        }
      }

      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = "#020409";
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(120, 255, 120, 0.6)";
      const topLeft = worldToScreen(0, 0);
      const bottomRight = worldToScreen(world.width, world.height);
      const w = bottomRight.x - topLeft.x;
      const h = bottomRight.y - topLeft.y;
      ctx.strokeRect(topLeft.x, topLeft.y, w, h);
      ctx.restore();

      ctx.save();
      for (const f of foodRaw) {
        const p = worldToScreen(f.x, f.y);
        if (p.x < -20 || p.y < -20 || p.x > width + 20 || p.y > height + 20) continue;
        const r = 1.2 * zoom;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fillStyle = "hsl(120, 100%, 70%)";
        ctx.fill();
      }
      ctx.restore();

      ctx.save();
      const clanSize = new Map();
      for (const bb of bacteriaRaw) {
        const fid = bb.familyId || 0;
        clanSize.set(fid, (clanSize.get(fid) || 0) + 1);
      }

      for (const leader of renderBacteria) {
        if (!leader.isLeader) continue;
        const fid = leader.familyId || 0;
        if (!fid) continue;

        const radiusWorld = leader.clanRadius || 120;
        const p = worldToScreen(leader.x, leader.y);
        const radius = radiusWorld * zoom;
        if (p.x < -radius || p.y < -radius || p.x > width + radius || p.y > height + radius) continue;

        const c = leader.familyColor || leader.color || "#58a6ff";

        ctx.globalAlpha = 0.08;
        ctx.fillStyle = c;
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = c;
        ctx.lineWidth = Math.max(1, 1.5 * zoom);
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.stroke();

        ctx.globalAlpha = 1;
      }
      ctx.restore();

      ctx.save();
      for (const b of renderBacteria) {
        const p = worldToScreen(b.x, b.y);
        if (p.x < -80 || p.y < -80 || p.x > width + 80 || p.y > height + 80) continue;

        const radius = Math.max(2, b.size * zoom);

        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = b.familyColor || "#58a6ff";
        ctx.shadowBlur = radius * 1.5;
        ctx.shadowColor = ctx.fillStyle;
        ctx.fill();
        ctx.shadowBlur = 0;

        if (b.isLeader) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius + 3, 0, Math.PI * 2);
          ctx.stroke();
        }

        if (selectedBacteriumId === b.id) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(46, 160, 67, 0.95)";
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius + 6, 0, Math.PI * 2);
          ctx.stroke();
        }

        const barWidth = radius * 2.6;
        const barHeight = 3;
        const barX = p.x - barWidth / 2;
        const barY = p.y - radius - 8;

        ctx.fillStyle = "rgba(80, 80, 80, 0.6)";
        ctx.fillRect(barX, barY, barWidth, barHeight);

        const hungerRatio = Math.max(0, Math.min(1, b.hunger / b.maxHunger));
        ctx.fillStyle = hungerRatio > 0.3 ? "rgba(144, 238, 144, 0.9)" : "rgba(255, 99, 71, 0.95)";
        ctx.fillRect(barX, barY, barWidth * hungerRatio, barHeight);

        ctx.textAlign = "center";
        ctx.fillStyle = "#ffffff";
        ctx.font = "10px system-ui";
        if (b.isLeader) ctx.fillText(b.name, p.x, barY - 3);
      }
      ctx.restore();

      requestAnimationFrame(draw);
    }

    function updateLeftHud() {
      const count = bacteriaRaw.length;
      const foodCount = foodRaw.length;

      let maxGeneration = 0;
      let maxAge = 0;
      for (const b of bacteriaRaw) {
        if (b.generation > maxGeneration) maxGeneration = b.generation;
        if (b.ageYears !== undefined && b.ageYears > maxAge) maxAge = b.ageYears;
      }

      const totalBorn = lastStats ? lastStats.totalBorn : 0;
      const totalDied = lastStats ? lastStats.totalDied : 0;

      hudRow1.innerHTML =
        `<span class="label">Бактерий:</span><span class="value">${count}</span>` +
        `<span class="label">Еда:</span><span class="value">${foodCount}</span>` +
        `<span class="label">Мир:</span><span class="value">${world.width}×${world.height}</span>`;

      hudRow2.innerHTML =
        `<span class="label">Родилось:</span><span class="value">${totalBorn}</span>` +
        `<span class="label">Умерло:</span><span class="value">${totalDied}</span>`;

      hudRow3.innerHTML =
        `<span class="label">Макс. поколение:</span><span class="value">${Math.floor(maxGeneration)}</span>` +
        `<span class="label">Макс. возраст:</span><span class="value">${maxAge.toFixed(1)} лет</span>`;
    }

    function updateRightHud() {
      if (!bacteriaRaw || bacteriaRaw.length === 0) {
        leadersListEl.innerHTML = "<div class='leader-info'>Пока нет бактерий</div>";
        detailPanel.style.display = "none";
        return;
      }

      const clanSize = new Map();
      for (const b of bacteriaRaw) {
        const id = b.familyId || 0;
        clanSize.set(id, (clanSize.get(id) || 0) + 1);
      }

      const leaders = [];
      const others = [];
      for (const b of bacteriaRaw) {
        if (b.isLeader) leaders.push(b);
        else others.push(b);
      }

      const byAgeDesc = (a, b) => {
        const aa = a.ageYears || 0;
        const bb = b.ageYears || 0;
        return bb - aa;
      };

      leaders.sort(byAgeDesc);
      others.sort(byAgeDesc);
      const all = leaders.concat(others);

      let html = "";
      let index = 1;
      for (const b of all) {
        const ageLabel = formatAgeLabel(b.ageYears);
        const size = clanSize.get(b.familyId || 0) || 1;
        const leaderMark = b.isLeader ? " ⭐" : "";
        const selectedClass = (selectedBacteriumId === b.id) ? " row-selected" : "";
        html += `<div class="leader-row${selectedClass}" data-id="${b.id}">
          <div class="leader-main">
            <span class="leader-name" style="color: ${b.familyColor || "#58a6ff"};">${index}. ${b.name}${leaderMark}</span>
            <span class="leader-clan">${b.familyName || ""}</span>
          </div>
          <div class="leader-info">
            Возраст: ${ageLabel} · В клане: ${size}
          </div>
        </div>`;
        index++;
      }

      leadersListEl.innerHTML = html;
    }

    function updateDetailPanel(b) {
      if (!b) {
        detailPanel.style.display = "none";
        detailContent.innerHTML = "";
        return;
      }
      const ageYears = b.ageYears ?? 0;
      const ageLabel = formatAgeLabel(ageYears);
      const sizePoints = b.sizePoints ?? b.size ?? 0;
      const maxSizePoints = b.maxSizePoints ?? 1000;
      const hunger = Math.round(b.hunger ?? 0);
      const maxHunger = b.maxHunger ?? 100;
      const children = b.childrenCount ?? 0;

      const isLeader = !!b.isLeader;
      const statusHtml = isLeader
        ? '<span style="color:#ffeb3b; font-weight:600;">ЛИДЕР ⭐</span>'
        : (b.familyId && b.familyId !== 0 ? 'Член клана' : 'Одиночка');

      const clanName = b.familyName || "Нет";
      const clanColor = b.familyColor || "#58a6ff";
      const clanRadius = b.isLeader && b.clanRadius ? Math.round(b.clanRadius) : "—";

      detailContent.innerHTML = `
        <div class="detail-row"><span class="label">Имя:</span> <span style="color:${clanColor}; font-weight:500;">${b.name}</span></div>
        <div class="detail-row"><span class="label">Статус:</span> ${statusHtml}</div>
        <div class="detail-row"><span class="label">Клан:</span> <span style="color:${clanColor};">${clanName}${b.familyId ? ` (ID: ${b.familyId})` : ""}</span></div>
        <div class="detail-row"><span class="label">Радиус клана:</span> ${clanRadius}</div>
        <div class="detail-row"><span class="label">Возраст:</span> ${ageLabel} (${ageYears.toFixed(2)} лет)</div>
        <div class="detail-row"><span class="label">Поколение:</span> ${Math.floor(b.generation || 0)}</div>
        <div class="detail-row"><span class="label">Размер:</span> ${Math.round(sizePoints)}/${maxSizePoints}</div>
        <div class="detail-row"><span class="label">Голод:</span> ${hunger}/${maxHunger}</div>
        <div class="detail-row"><span class="label">Потомков:</span> ${children}</div>
        <div class="detail-row"><span class="label">Координаты:</span> X: ${Math.round(b.x)}, Y: ${Math.round(b.y)}</div>
      `;
      detailPanel.style.display = "block";
    }

    leadersListEl.addEventListener("pointerdown", (e) => {
      const row = e.target.closest(".leader-row");
      if (!row) return;
      lastHudInteractionTime = Date.now();
      const idStr = row.getAttribute("data-id");
      const id = parseInt(idStr, 10);
      if (!Number.isFinite(id)) return;

      if (selectedBacteriumId === id) {
        selectedBacteriumId = null;
        updateDetailPanel(null);
      } else {
        selectedBacteriumId = id;
        const b = bacteriaRaw.find(b => b.id === id);
        updateDetailPanel(b || null);
      }
      updateRightHud();
    });

    async function fetchState() {
      try {
        const res = await fetch(SERVER_URL + "/state", { cache: "no-cache" });
        const data = await res.json();
        world = data.world || world;

        bacteriaRaw = data.bacteria || [];
        foodRaw = data.food || [];
        lastStats = data.stats || null;

        if (!lastServerOk) {
          lastServerOk = true;
          serverDot.classList.remove("server-bad");
          serverDot.classList.add("server-ok");
        }
        
        if (serverUptimeSeconds > 0) {
          const elapsed = Math.floor((Date.now() - uptimeLastFetch) / 1000);
          const uptime = formatUptime(serverUptimeSeconds + elapsed);
          serverStatusText.innerHTML = `Сервер: работает <span style="color: #79c0ff;">· ${uptime}</span>`;
        } else {
          serverStatusText.textContent = "Сервер: работает";
        }

        updateLeftHud();
        const now = Date.now();
        if (now - lastHudInteractionTime > 900) {
          updateRightHud();
        }

        if (selectedBacteriumId !== null) {
          const b = bacteriaRaw.find(b => b.id === selectedBacteriumId);
          if (b) {
            updateDetailPanel(b);
          } else {
            selectedBacteriumId = null;
            updateDetailPanel(null);
          }
        } else {
          updateDetailPanel(null);
        }
      } catch (err) {
        console.error("Ошибка fetchState:", err);
        lastServerOk = false;
        serverDot.classList.remove("server-ok");
        serverDot.classList.add("server-bad");
        serverStatusText.textContent = "Сервер: нет связи";
      }
    }

    async function fetchUptime() {
      try {
        const res = await fetch(SERVER_URL + "/ping", { cache: "no-cache" });
        const data = await res.json();
        if (data.uptime !== undefined) {
          serverUptimeSeconds = data.uptime;
          uptimeLastFetch = Date.now();
          const uptime = formatUptime(serverUptimeSeconds);
          if (lastServerOk) {
            serverStatusText.innerHTML = `Сервер: работает <span style="color: #79c0ff;">· ${uptime}</span>`;
          }
        }
      } catch (err) {
        // Игнорируем ошибки uptime
      }
    }

    setInterval(fetchUptime, 10000);
    setInterval(fetchState, 120);

    fetchState();
    fetchUptime();
    requestAnimationFrame(draw);
  </script>
</body>
</html>
