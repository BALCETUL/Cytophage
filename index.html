<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cytophage — семейный мир</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #020409;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e5e5e5;
    }
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at center, #050814 0%, #010206 60%, #000000 100%);
      cursor: grab;
    }
    #canvas:active {
      cursor: grabbing;
    }

    .hud {
      position: fixed;
      left: 10px;
      top: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      font-size: 12px;
      pointer-events: none;
      max-width: 360px;
    }
    .hud .row {
      margin-top: 3px;
      white-space: nowrap;
    }
    .hud .row span.label {
      display: inline-block;
      min-width: 110px;
      color: #8b949e;
    }
    .hud .row span.value {
      display: inline-block;
      min-width: 90px;
    }
    .server-row {
      display: flex;
      align-items: center;
    }
    .server-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      background: #6e7681;
      box-shadow: 0 0 4px rgba(0,0,0,0.8);
    }
    .server-ok {
      background: #2ea043;
      box-shadow: 0 0 8px rgba(46,160,67,0.9);
    }
    .server-bad {
      background: #f85149;
      box-shadow: 0 0 8px rgba(248,81,73,0.9);
    }

    .right-container {
      position: fixed;
      right: 10px;
      top: 10px;
      display: flex;
      gap: 10px;
      max-height: calc(100vh - 20px);
    }
    .hud-right {
      width: 280px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      font-size: 12px;
      max-height: 100%;
      overflow-y: auto;
      pointer-events: auto;
    }
    .hud-right-title {
      font-weight: 600;
      color: #79c0ff;
      margin-bottom: 4px;
      position: sticky;
      top: 0;
      background: rgba(0, 0, 0, 0.9);
      padding-bottom: 3px;
      z-index: 1;
    }
    .leader-row {
      margin-top: 3px;
      border-bottom: 1px solid rgba(110,118,129,0.3);
      padding: 3px 12px 3px 18px;
      cursor: pointer;
      position: relative;
    }
    .leader-row:last-child {
      border-bottom: none;
    }
    .leader-row:hover {
      background: rgba(56,139,253,0.15);
    }
    .leader-focus-btn {
      position: absolute;
      left: 6px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid #f85149;
      color: #f85149;
      font-size: 12px;
      line-height: 14px;
      text-align: center;
      background: rgba(248,81,73,0.1);
      box-shadow: 0 0 4px rgba(248,81,73,0.7);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.12s ease-out, transform 0.12s ease-out;
    }
    .leader-row:hover .leader-focus-btn {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(-50%) scale(1.03);
    }
    .row-selected .leader-focus-btn {
      opacity: 1;
      border-color: #2ea043;
      color: #2ea043;
      box-shadow: 0 0 6px rgba(46,160,67,0.9);
      background: rgba(46,160,67,0.12);
    }
    .row-selected {
      border: 1px solid #2ea043;
      background: rgba(46,160,67,0.25);
    }
    .leader-main {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }
    .leader-name {
      font-weight: 500;
    }
    .leader-clan {
      color: #8b949e;
      margin-left: 6px;
    }
    .leader-info {
      font-size: 11px;
      color: #c9d1d9;
      white-space: nowrap;
    }

    .controls {
      position: fixed;
      left: 10px;
      bottom: 10px;
      display: flex;
      gap: 8px;
      pointer-events: auto;
    }
    .btn {
      border: 1px solid #30363d;
      background: rgba(13,17,23,0.9);
      color: #e5e5e5;
      border-radius: 6px;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
    }
    .btn:hover {
      background: rgba(22,27,34,0.95);
    }
    .btn-active {
      border-color: #2ea043;
      box-shadow: 0 0 6px rgba(46,160,67,0.6);
    }

    /* Панель деталей выбранной бактерии */
    #selectedBacteriumDetail {
      width: 280px;
      padding: 10px 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      font-size: 12px;
      overflow-y: auto;
      pointer-events: auto;
      border: 1px solid rgba(46,160,67,0.5);
      display: none;
    }
    .detail-title {
      font-weight: 600;
      color: #2ea043;
      margin-bottom: 8px;
    }
    .detail-row {
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(110,118,129,0.25);
      padding-bottom: 4px;
    }
    .detail-row .label {
      color: #8b949e;
      display: inline-block;
      min-width: 110px;
    }
    .detail-title {
      font-weight: 600;
      color: #2ea043;
      margin-bottom: 4px;
    }
    .detail-row {
      margin-bottom: 3px;
    }
    .detail-row .label {
      color: #8b949e;
      display: inline-block;
      min-width: 90px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- Левая панель: статус и общая инфа -->
  <div class="hud">
    <div class="row server-row">
      <div id="serverDot" class="server-dot"></div>
      <div id="serverStatusText">Сервер: нет данных</div>
    </div>
    <div class="row" id="hudRow1"></div>
    <div class="row" id="hudRow2"></div>
    <div class="row" id="hudRow3"></div>
  </div>

  <!-- Правая панель: список бактерий + отдельная панель деталей сбоку -->
  <div class="right-container">
    <div id="selectedBacteriumDetail">
      <div class="detail-title">Детали выбранной бактерии</div>
      <div id="detailContent"></div>
    </div>
    <div class="hud-right">
      <div class="hud-right-title">Бактерии и кланы</div>
      <div id="leadersList"></div>
    </div>
  </div>

  <!-- Кнопки управления -->
  <div class="controls">
    <button id="toggleDetails" class="btn">Показать детали бактерий</button>
  </div>

  <script>
    const SERVER_URL = "https://cytophage.onrender.com";

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const hudRow1 = document.getElementById("hudRow1");
    const hudRow2 = document.getElementById("hudRow2");
    const hudRow3 = document.getElementById("hudRow3");
    const serverDot = document.getElementById("serverDot");
    const serverStatusText = document.getElementById("serverStatusText");
    const leadersListEl = document.getElementById("leadersList");
    const toggleDetailsBtn = document.getElementById("toggleDetails");
    const detailPanel = document.getElementById("selectedBacteriumDetail");
    const detailContent = document.getElementById("detailContent");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    let world = { width: 8000, height: 8000 };
    let worldWidth = world.width;
    let worldHeight = world.height;

    // Камера
    let cameraX = worldWidth / 2;
    let cameraY = worldHeight / 2;
    let zoom = 0.1;

    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let cameraStartX = 0;
    let cameraStartY = 0;

    let showDetails = false;
    let lastStats = null;
    let lastServerOk = false;
    
    // UPTIME - просто храним последнее значение с сервера
    let serverUptimeSeconds = 0;
    let uptimeLastFetch = Date.now();

    // "сырые" данные с сервера
    let bacteriaRaw = [];
    let foodRaw = [];

    // сглаженные позиции (чтобы не дёргалось)
    // id -> { x, y }
    const renderPositions = new Map();

    let selectedBacteriumId = null;
    let lastHudInteractionTime = 0;

    // Функция форматирования времени работы
    function formatUptime(seconds) {
      if (!seconds || seconds < 0) return "—";
      
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);

      const parts = [];
      if (days > 0) parts.push(`${days}д`);
      if (hours > 0) parts.push(`${hours}ч`);
      if (minutes > 0) parts.push(`${minutes}м`);
      if (secs > 0 || parts.length === 0) parts.push(`${secs}с`);

      return parts.join(' ');
    }

    // Плавное обновление uptime между запросами
    setInterval(() => {
      if (lastServerOk && serverUptimeSeconds > 0) {
        const elapsed = Math.floor((Date.now() - uptimeLastFetch) / 1000);
        const uptime = formatUptime(serverUptimeSeconds + elapsed);
        serverStatusText.innerHTML = `Сервер: работает <span style="color: #79c0ff;">· ${uptime}</span>`;
      }
    }, 1000);

    toggleDetailsBtn.addEventListener("click", () => {
      showDetails = !showDetails;
      toggleDetailsBtn.textContent = showDetails
        ? "Скрыть детали бактерий"
        : "Показать детали бактерий";
      if (showDetails) {
        toggleDetailsBtn.classList.add("btn-active");
      } else {
        toggleDetailsBtn.classList.remove("btn-active");
      }
    });

    canvas.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      cameraStartX = cameraX;
      cameraStartY = cameraY;
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      cameraX = cameraStartX - dx / zoom;
      cameraY = cameraStartY - dy / zoom;
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = 1.1;
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      const worldBeforeZoomX = (mouseX - width / 2) / zoom + cameraX;
      const worldBeforeZoomY = (mouseY - height / 2) / zoom + cameraY;

      if (e.deltaY < 0) {
        zoom *= zoomFactor;
      } else {
        zoom /= zoomFactor;
      }

      zoom = Math.max(0.02, Math.min(zoom, 2));

      const worldAfterZoomX = (mouseX - width / 2) / zoom + cameraX;
      const worldAfterZoomY = (mouseY - height / 2) / zoom + cameraY;

      cameraX += worldBeforeZoomX - worldAfterZoomX;
      cameraY += worldBeforeZoomY - worldAfterZoomY;
    }, { passive: false });

    function worldToScreen(x, y) {
      const sx = (x - cameraX) * zoom + width / 2;
      const sy = (y - cameraY) * zoom + height / 2;
      return { x: sx, y: sy };
    }

    function formatAgeLabel(ageYears) {
      if (ageYears === undefined || isNaN(ageYears)) return "?";
      if (ageYears < 0.2) return "Новорождённый";
      if (ageYears < 0.5) return "Малыш";
      if (ageYears < 1.0) return "Юный";

      const yearsInt = Math.floor(ageYears);
      const lastTwo = yearsInt % 100;
      const lastDigit = yearsInt % 10;
      let word;
      if (lastTwo >= 11 && lastTwo <= 14) {
        word = "лет";
      } else if (lastDigit === 1) {
        word = "год";
      } else if (lastDigit >= 2 && lastDigit <= 4) {
        word = "года";
      } else {
        word = "лет";
      }
      return yearsInt + " " + word;
    }

    function getRenderBacteriaList() {
      // очищаем позиции для умерших
      const currentIds = new Set(bacteriaRaw.map(b => b.id));
      for (const id of renderPositions.keys()) {
        if (!currentIds.has(id)) {
          renderPositions.delete(id);
        }
      }

      const smoothed = [];
      const alpha = 0.025; // ультра-сильное сглаживание
      const maxStep = 6; // минимальный шаг смещения за кадр в координатах мира

      for (const b of bacteriaRaw) {
        let rp = renderPositions.get(b.id);
        if (!rp) {
          rp = { x: b.x, y: b.y };
          renderPositions.set(b.id, rp);
        } else {
          let dx = b.x - rp.x;
          let dy = b.y - rp.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 0;
          if (dist > maxStep) {
            const k = maxStep / dist;
            dx *= k;
            dy *= k;
          }
          rp.x += dx * alpha;
          rp.y += dy * alpha;
        }
        smoothed.push({
          ...b,
          x: rp.x,
          y: rp.y
        });
      }
      return smoothed;
    }

    function draw() {
      const renderBacteria = getRenderBacteriaList();

      // камера следует за выбранной бактерией — по сглаженным координатам
      if (selectedBacteriumId !== null) {
        const target = renderBacteria.find(b => b.id === selectedBacteriumId);
        if (target) {
          const lerp = 0.03; // ещё более мягкое движение камеры
          cameraX += (target.x - cameraX) * lerp;
          cameraY += (target.y - cameraY) * lerp;
          // ограничиваем максимальное смещение камеры за кадр, чтобы не было рывков
          const maxCamStep = 20;
          const dcx = target.x - cameraX;
          const dcy = target.y - cameraY;
          const camDist = Math.sqrt(dcx * dcx + dcy * dcy) || 0;
          if (camDist > maxCamStep) {
            const kk = maxCamStep / camDist;
            cameraX = target.x - dcx * kk;
            cameraY = target.y - dcy * kk;
          }
        } else {
          selectedBacteriumId = null;
        }
      }

      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = "#020409";
      ctx.fillRect(0, 0, width, height);

      // границы мира
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(120, 255, 120, 0.6)";
      const topLeft = worldToScreen(0, 0);
      const bottomRight = worldToScreen(world.width, world.height);
      const w = bottomRight.x - topLeft.x;
      const h = bottomRight.y - topLeft.y;
      ctx.strokeRect(topLeft.x, topLeft.y, w, h);
      ctx.restore();

      // еда
      ctx.save();
      for (const f of foodRaw) {
        const p = worldToScreen(f.x, f.y);
        if (p.x < -20 || p.y < -20 || p.x > width + 20 || p.y > height + 20) continue;
        const r = 1.2 * zoom;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fillStyle = "hsl(120, 100%, 70%)";
        ctx.fill();
      }
      ctx.restore();

      // круг территории клана (цвет = цвет лидера)
      // Важно: рисуем по тем же сглаженным координатам, что и бактерии, иначе будет "дёргаться".
      ctx.save();
      const clanSize = new Map();
      for (const bb of bacteriaRaw) {
        const fid = bb.familyId || 0;
        clanSize.set(fid, (clanSize.get(fid) || 0) + 1);
      }

      // Fallback-формула радиуса на клиенте (если сервер не прислал clanRadius)
      const CLAN_RADIUS_BASE = 14;
      const CLAN_RADIUS_PER_SQRT_MEMBER = 2;
      const CLAN_RADIUS_MAX = 30;

      for (const leader of renderBacteria) {
        if (!leader.isLeader) continue;
        const fid = leader.familyId || 0;
        if (!fid) continue;

        const size = clanSize.get(fid) || 1;
        const radiusWorld = (leader.clanRadius ?? leader.familyRadius ?? leader.territoryRadius ?? Math.min(CLAN_RADIUS_MAX, CLAN_RADIUS_BASE + Math.sqrt(size) * CLAN_RADIUS_PER_SQRT_MEMBER));

        const p = worldToScreen(leader.x, leader.y);
        const radius = radiusWorld * zoom;
        if (p.x < -radius || p.y < -radius || p.x > width + radius || p.y > height + radius) continue;

        const c = leader.familyColor || leader.color || "#58a6ff";

        // лёгкая заливка
        ctx.globalAlpha = 0.05;
        ctx.fillStyle = c;
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fill();

        // обводка
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = c;
        ctx.lineWidth = Math.max(1, 1.5 * zoom);
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.stroke();

        ctx.globalAlpha = 1;
      }
      ctx.restore();

      // бактерии
      ctx.save();
      for (const b of renderBacteria) {
        const p = worldToScreen(b.x, b.y);
        if (p.x < -80 || p.y < -80 || p.x > width + 80 || p.y > height + 80) continue;

        const radius = Math.max(2, b.size * zoom);

        // тело (цвет клана)
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = b.familyColor || "#58a6ff";
        ctx.shadowBlur = radius * 1.5;
        ctx.shadowColor = ctx.fillStyle;
        ctx.fill();
        ctx.shadowBlur = 0;

        // кольцо лидера
        if (b.isLeader) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius + 3, 0, Math.PI * 2);
          ctx.stroke();
        }

        // выделение выбранной бактерии (зелёная рамка)
        if (selectedBacteriumId === b.id) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(46, 160, 67, 0.95)";
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius + 6, 0, Math.PI * 2);
          ctx.stroke();
        }

        // полоска голода
        const barWidth = radius * 2.6;
        const barHeight = 3;
        const barX = p.x - barWidth / 2;
        const barY = p.y - radius - 8;

        ctx.fillStyle = "rgba(80, 80, 80, 0.6)";
        ctx.fillRect(barX, barY, barWidth, barHeight);

        const hungerRatio = Math.max(0, Math.min(1, b.hunger / b.maxHunger));
        ctx.fillStyle = hungerRatio > 0.3 ? "rgba(144, 238, 144, 0.9)" : "rgba(255, 99, 71, 0.95)";
        ctx.fillRect(barX, barY, barWidth * hungerRatio, barHeight);

        // имя над бактерией
        ctx.textAlign = "center";
        ctx.fillStyle = "#ffffff";
        ctx.font = "10px system-ui";
        ctx.fillText(b.name, p.x, barY - 3);

        // подробные таблички, если включено (снизу)
        if (showDetails) {
          const startY = p.y + radius + 25;
          const lineH = 11;

          const ageLabel = formatAgeLabel(b.ageYears);
          ctx.textAlign = "center";
          ctx.font = "9px system-ui";
          ctx.fillStyle = "#e6edf3";
          ctx.fillText(`Клан: ${b.familyName || "нет"}`, p.x, startY);
          ctx.fillText(`Возраст: ${ageLabel}`, p.x, startY + lineH);
          ctx.fillText(`Поколение: ${Math.floor(b.generation)}`, p.x, startY + lineH * 2);
          ctx.fillText(`Размер: ${Math.round(b.sizePoints)}/${b.maxSizePoints}`, p.x, startY + lineH * 3);
          ctx.fillText(`Голод: ${Math.round(b.hunger)}/${b.maxHunger}`, p.x, startY + lineH * 4);
          ctx.fillText(`Потомков: ${b.childrenCount}`, p.x, startY + lineH * 5);
          if (b.isLeader) {
            ctx.fillStyle = "#ffa657";
            ctx.fillText(`Лидер колонии`, p.x, startY + lineH * 6);
          }
        }
      }
      ctx.restore();

      requestAnimationFrame(draw);
    }

    function updateLeftHud() {
      const count = bacteriaRaw.length;
      const foodCount = foodRaw.length;

      let maxGeneration = 0;
      let maxAge = 0;
      for (const b of bacteriaRaw) {
        if (b.generation > maxGeneration) maxGeneration = b.generation;
        if (b.ageYears !== undefined && b.ageYears > maxAge) maxAge = b.ageYears;
      }

      const totalBorn = lastStats ? lastStats.totalBorn : 0;
      const totalDied = lastStats ? lastStats.totalDied : 0;

      hudRow1.innerHTML =
        `<span class="label">Бактерий:</span><span class="value">${count}</span>` +
        `<span class="label">Еда:</span><span class="value">${foodCount}</span>` +
        `<span class="label">Мир:</span><span class="value">${world.width}×${world.height}</span>`;

      hudRow2.innerHTML =
        `<span class="label">Родилось:</span><span class="value">${totalBorn}</span>` +
        `<span class="label">Умерло:</span><span class="value">${totalDied}</span>`;

      hudRow3.innerHTML =
        `<span class="label">Макс. поколение:</span><span class="value">${Math.floor(maxGeneration)}</span>` +
        `<span class="label">Макс. возраст:</span><span class="value">${maxAge.toFixed(1)} лет</span>`;
    }

    function updateRightHud() {
      if (!bacteriaRaw || bacteriaRaw.length === 0) {
        leadersListEl.innerHTML = "<div class='leader-info'>Пока нет бактерий</div>";
        detailPanel.style.display = "none";
        return;
      }

      const clanSize = new Map();
      for (const b of bacteriaRaw) {
        const id = b.familyId || 0;
        clanSize.set(id, (clanSize.get(id) || 0) + 1);
      }

      const leaders = [];
      const others = [];
      for (const b of bacteriaRaw) {
        if (b.isLeader) leaders.push(b);
        else others.push(b);
      }

      const byAgeDesc = (a, b) => {
        const aa = a.ageYears || 0;
        const bb = b.ageYears || 0;
        return bb - aa;
      };

      leaders.sort(byAgeDesc);
      others.sort(byAgeDesc);
      const all = leaders.concat(others);

      let html = "";
      let index = 1;
      for (const b of all) {
        const ageLabel = formatAgeLabel(b.ageYears);
        const size = clanSize.get(b.familyId || 0) || 1;
        const leaderMark = b.isLeader ? " ⭐" : "";
        const selectedClass = (selectedBacteriumId === b.id) ? " row-selected" : "";
        html += `<div class="leader-row${selectedClass}" data-id="${b.id}">
          <div class="leader-main">
            <span class="leader-name" style="color: ${b.familyColor || "#58a6ff"};">${index}. ${b.name}${leaderMark}</span>
            <span class="leader-clan">${b.familyName || ""}</span>
          </div>
          <div class="leader-info">
            Возраст: ${ageLabel} · В клане: ${size}
          </div>
        </div>`;
        index++;
      }

      leadersListEl.innerHTML = html;
    }

    function updateDetailPanel(b) {
      if (!b) {
        detailPanel.style.display = "none";
        detailContent.innerHTML = "";
        return;
      }
      const ageYears = b.ageYears ?? 0;
      const ageLabel = formatAgeLabel(ageYears);
      const sizePoints = (b.sizePoints !== undefined ? b.sizePoints : (b.size || 0));
      const maxSizePoints = (b.maxSizePoints !== undefined ? b.maxSizePoints : "?");
      const hunger = Math.round(b.hunger ?? 0);
      const maxHunger = b.maxHunger ?? "?";
      const children = b.childrenCount ?? 0;

      const isLeader = !!b.isLeader;
      const statusHtml = isLeader
        ? '<span style="color:#ffeb3b; font-weight:600;">ЛИДЕР ⭐</span>'
        : (b.familyId && b.familyId !== 0 ? 'Член клана' : 'Одиночка');

      const clanName = b.familyName || "Нет";
      const clanColor = b.familyColor || "#58a6ff";

      detailContent.innerHTML = `
        <div class="detail-row"><span class="label">Имя:</span> <span style="color:${clanColor}; font-weight:500;">${b.name}</span></div>
        <div class="detail-row"><span class="label">Статус:</span> ${statusHtml}</div>
        <div class="detail-row"><span class="label">Клан:</span> <span style="color:${clanColor};">${clanName}${b.familyId ? ` (ID: ${b.familyId})` : ""}</span></div>
        <div class="detail-row"><span class="label">Возраст:</span> ${ageLabel} (${ageYears.toFixed(2)} лет)</div>
        <div class="detail-row"><span class="label">Поколение:</span> ${Math.floor(b.generation || 0)}</div>
        <div class="detail-row"><span class="label">Размер:</span> ${Math.round(sizePoints)}/${maxSizePoints}</div>
        <div class="detail-row"><span class="label">Голод:</span> ${hunger}/${maxHunger}</div>
        <div class="detail-row"><span class="label">Потомков:</span> ${children}</div>
        <div class="detail-row"><span class="label">Координаты:</span> X: ${Math.round(b.x)}, Y: ${Math.round(b.y)}</div>
      `;
      detailPanel.style.display = "block";
    }

    leadersListEl.addEventListener("pointerdown", (e) => {
      const row = e.target.closest(".leader-row");
      if (!row) return;
      lastHudInteractionTime = Date.now();
      const idStr = row.getAttribute("data-id");
      const id = parseInt(idStr, 10);
      if (!Number.isFinite(id)) return;

      if (selectedBacteriumId === id) {
        selectedBacteriumId = null;
        updateDetailPanel(null);
      } else {
        selectedBacteriumId = id;
        const b = bacteriaRaw.find(b => b.id === id);
        updateDetailPanel(b || null);
      }
      updateRightHud();
    });

    async function fetchState() {
      try {
        const res = await fetch(SERVER_URL + "/state", { cache: "no-cache" });
        const data = await res.json();
        world = data.world || world;
        worldWidth = world.width;
        worldHeight = world.height;

        bacteriaRaw = data.bacteria || [];
        foodRaw = data.food || [];
        lastStats = data.stats || null;

        if (!lastServerOk) {
          lastServerOk = true;
          serverDot.classList.remove("server-bad");
          serverDot.classList.add("server-ok");
        }
        
        // Обновляем текст с временем работы
        if (serverUptimeSeconds > 0) {
          const elapsed = Math.floor((Date.now() - uptimeLastFetch) / 1000);
          const uptime = formatUptime(serverUptimeSeconds + elapsed);
          serverStatusText.innerHTML = `Сервер: работает <span style="color: #79c0ff;">· ${uptime}</span>`;
        } else {
          serverStatusText.textContent = "Сервер: работает";
        }

        updateLeftHud();
        const now = Date.now();
        if (now - lastHudInteractionTime > 900) {
          updateRightHud();
        }

        // Обновляем панель деталей, если кто-то выбран
        if (selectedBacteriumId !== null) {
          const b = bacteriaRaw.find(b => b.id === selectedBacteriumId);
          if (b) {
            updateDetailPanel(b);
          } else {
            selectedBacteriumId = null;
            updateDetailPanel(null);
          }
        } else {
          updateDetailPanel(null);
        }
      } catch (err) {
        console.error("Ошибка fetchState:", err);
        lastServerOk = false;
        serverDot.classList.remove("server-ok");
        serverDot.classList.add("server-bad");
        serverStatusText.textContent = "Сервер: нет связи";
      }
    }

    // Получаем uptime с сервера
    async function fetchUptime() {
      try {
        const res = await fetch(SERVER_URL + "/ping", { cache: "no-cache" });
        const data = await res.json();
        if (data.uptime !== undefined) {
          serverUptimeSeconds = data.uptime;
          uptimeLastFetch = Date.now();
          const uptime = formatUptime(serverUptimeSeconds);
          if (lastServerOk) {
            serverStatusText.innerHTML = `Сервер: работает <span style="color: #79c0ff;">· ${uptime}</span>`;
          }
        }
      } catch (err) {
        // Игнорируем ошибки uptime
      }
    }

    // Обновляем uptime каждые 10 секунд
    setInterval(fetchUptime, 10000);

    // более частое обновление состояния + сильное сглаживание
    setInterval(fetchState, 120); // чаще обновляем состояние

    // стартуем
    fetchState();
    fetchUptime();
    requestAnimationFrame(draw);
  </script>
</body>
</html>
