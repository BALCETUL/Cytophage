<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cytophage — семейный мир</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #020409;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e5e5e5;
    }
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at center, #050814 0%, #010206 60%, #000000 100%);
      cursor: grab;
    }
    #canvas:active {
      cursor: grabbing;
    }

    .hud {
      position: fixed;
      left: 10px;
      top: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      font-size: 12px;
      pointer-events: none;
      max-width: 360px;
    }
    .hud .row {
      margin-top: 3px;
      white-space: nowrap;
    }
    .hud .row span.label {
      display: inline-block;
      min-width: 110px;
      color: #8b949e;
    }
    .hud .row span.value {
      display: inline-block;
      min-width: 90px;
    }
    .server-row {
      display: flex;
      align-items: center;
    }
    .server-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      background: #6e7681;
      box-shadow: 0 0 4px rgba(0,0,0,0.8);
    }
    .server-ok {
      background: #2ea043;
      box-shadow: 0 0 8px rgba(46,160,67,0.9);
    }
    .server-bad {
      background: #f85149;
      box-shadow: 0 0 8px rgba(248,81,73,0.9);
    }

    .hud-right {
      position: fixed;
      right: 10px;
      top: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      font-size: 12px;
      max-width: 360px;
      min-width: 280px;
      max-height: 520px;
      overflow-y: auto;
      pointer-events: auto;
    }
    .hud-right-title {
      font-weight: 600;
      color: #79c0ff;
      margin-bottom: 4px;
      position: sticky;
      top: 0;
      background: rgba(0, 0, 0, 0.9);
      padding-bottom: 3px;
      z-index: 1;
    }
    .leader-row {
      margin-top: 3px;
      border-bottom: 1px solid rgba(110,118,129,0.3);
      padding: 3px 2px;
      cursor: pointer;
    }
    .leader-row:last-child {
      border-bottom: none;
    }
    .leader-row:hover {
      background: rgba(56,139,253,0.15);
    }
    .row-selected {
      border: 1px solid #2ea043;
      background: rgba(46,160,67,0.25);
    }
    .leader-main {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }
    .leader-name {
      font-weight: 500;
    }
    .leader-clan {
      color: #8b949e;
      margin-left: 4px;
    }
    .leader-info {
      font-size: 11px;
      color: #c9d1d9;
      white-space: nowrap;
    }

    .controls {
      position: fixed;
      left: 10px;
      bottom: 10px;
      display: flex;
      gap: 8px;
      pointer-events: auto;
    }
    .btn {
      border: 1px solid #30363d;
      background: rgba(13,17,23,0.9);
      color: #e5e5e5;
      border-radius: 6px;
      padding: 4px 10px;
      font-size: 11px;
      cursor: pointer;
    }
    .btn:hover {
      background: rgba(22,27,34,0.95);
    }
    .btn-active {
      border-color: #2ea043;
      box-shadow: 0 0 6px rgba(46,160,67,0.6);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <!-- Левая панель: статус и общая инфа -->
  <div class="hud">
    <div class="row server-row">
      <div id="serverDot" class="server-dot"></div>
      <div id="serverStatusText">Сервер: нет данных</div>
    </div>
    <div class="row" id="hudRow1"></div>
    <div class="row" id="hudRow2"></div>
    <div class="row" id="hudRow3"></div>
  </div>

  <!-- Правая панель: список всех бактерий (лидеры первыми) -->
  <div class="hud-right">
    <div class="hud-right-title">Бактерии и кланы</div>
    <div id="leadersList"></div>
  </div>

  <!-- Кнопки управления -->
  <div class="controls">
    <button id="toggleDetails" class="btn">Показать детали бактерий</button>
  </div>

  <script>
    const SERVER_URL = "https://cytophage.onrender.com";

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const hudRow1 = document.getElementById("hudRow1");
    const hudRow2 = document.getElementById("hudRow2");
    const hudRow3 = document.getElementById("hudRow3");
    const serverDot = document.getElementById("serverDot");
    const serverStatusText = document.getElementById("serverStatusText");
    const leadersListEl = document.getElementById("leadersList");
    const toggleDetailsBtn = document.getElementById("toggleDetails");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    let world = { width: 8000, height: 8000 };
    let worldWidth = world.width;
    let worldHeight = world.height;

    // Камера
    let cameraX = worldWidth / 2;
    let cameraY = worldHeight / 2;
    let zoom = 0.1;

    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let cameraStartX = 0;
    let cameraStartY = 0;

    let showDetails = false;
    let lastStats = null;
    let lastServerOk = false;

    // "сырые" данные с сервера
    let bacteriaRaw = [];
    let foodRaw = [];

    // сглаженные позиции (чтобы не дёргалось)
    // id -> { x, y }
    const renderPositions = new Map();

    let selectedBacteriumId = null;

    toggleDetailsBtn.addEventListener("click", () => {
      showDetails = !showDetails;
      toggleDetailsBtn.textContent = showDetails
        ? "Скрыть детали бактерий"
        : "Показать детали бактерий";
      if (showDetails) {
        toggleDetailsBtn.classList.add("btn-active");
      } else {
        toggleDetailsBtn.classList.remove("btn-active");
      }
    });

    canvas.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      cameraStartX = cameraX;
      cameraStartY = cameraY;
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      cameraX = cameraStartX - dx / zoom;
      cameraY = cameraStartY - dy / zoom;
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomFactor = 1.1;
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      const worldBeforeZoomX = (mouseX - width / 2) / zoom + cameraX;
      const worldBeforeZoomY = (mouseY - height / 2) / zoom + cameraY;

      if (e.deltaY < 0) {
        zoom *= zoomFactor;
      } else {
        zoom /= zoomFactor;
      }

      zoom = Math.max(0.02, Math.min(zoom, 2));

      const worldAfterZoomX = (mouseX - width / 2) / zoom + cameraX;
      const worldAfterZoomY = (mouseY - height / 2) / zoom + cameraY;

      cameraX += worldBeforeZoomX - worldAfterZoomX;
      cameraY += worldBeforeZoomY - worldAfterZoomY;
    }, { passive: false });

    function worldToScreen(x, y) {
      const sx = (x - cameraX) * zoom + width / 2;
      const sy = (y - cameraY) * zoom + height / 2;
      return { x: sx, y: sy };
    }

    function formatAgeLabel(ageYears) {
      if (ageYears === undefined || isNaN(ageYears)) return "?";
      if (ageYears < 0.2) return "Новорождённый";
      if (ageYears < 0.5) return "Малыш";
      if (ageYears < 1.0) return "Юный";

      const yearsInt = Math.floor(ageYears);
      const lastTwo = yearsInt % 100;
      const lastDigit = yearsInt % 10;
      let word;
      if (lastTwo >= 11 && lastTwo <= 14) {
        word = "лет";
      } else if (lastDigit === 1) {
        word = "год";
      } else if (lastDigit >= 2 && lastDigit <= 4) {
        word = "года";
      } else {
        word = "лет";
      }
      return yearsInt + " " + word;
    }

    function getRenderBacteriaList() {
      // очищаем позиции для умерших
      const currentIds = new Set(bacteriaRaw.map(b => b.id));
      for (const id of renderPositions.keys()) {
        if (!currentIds.has(id)) {
          renderPositions.delete(id);
        }
      }

      const smoothed = [];
      const alpha = 0.025; // ультра-сильное сглаживание
      const maxStep = 6; // минимальный шаг смещения за кадр в координатах мира

      for (const b of bacteriaRaw) {
        let rp = renderPositions.get(b.id);
        if (!rp) {
          rp = { x: b.x, y: b.y };
          renderPositions.set(b.id, rp);
        } else {
          let dx = b.x - rp.x;
          let dy = b.y - rp.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 0;
          if (dist > maxStep) {
            const k = maxStep / dist;
            dx *= k;
            dy *= k;
          }
          rp.x += dx * alpha;
          rp.y += dy * alpha;
        }
        smoothed.push({
          ...b,
          x: rp.x,
          y: rp.y
        });
      }
      return smoothed;
    }

    function draw() {
      const renderBacteria = getRenderBacteriaList();

      // камера следует за выбранной бактерией — по сглаженным координатам
      if (selectedBacteriumId !== null) {
        const target = renderBacteria.find(b => b.id === selectedBacteriumId);
        if (target) {
          const lerp = 0.03; // ещё более мягкое движение камеры
          cameraX += (target.x - cameraX) * lerp;
          cameraY += (target.y - cameraY) * lerp;
          // ограничиваем максимальное смещение камеры за кадр, чтобы не было рывков
          const maxCamStep = 20;
          const dcx = target.x - cameraX;
          const dcy = target.y - cameraY;
          const camDist = Math.sqrt(dcx * dcx + dcy * dcy) || 0;
          if (camDist > maxCamStep) {
            const kk = maxCamStep / camDist;
            cameraX = target.x - dcx * kk;
            cameraY = target.y - dcy * kk;
          }
        } else {
          selectedBacteriumId = null;
        }
      }

      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = "#020409";
      ctx.fillRect(0, 0, width, height);

      // границы мира
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(120, 255, 120, 0.6)";
      const topLeft = worldToScreen(0, 0);
      const bottomRight = worldToScreen(world.width, world.height);
      const w = bottomRight.x - topLeft.x;
      const h = bottomRight.y - topLeft.y;
      ctx.strokeRect(topLeft.x, topLeft.y, w, h);
      ctx.restore();

      // еда
      ctx.save();
      for (const f of foodRaw) {
        const p = worldToScreen(f.x, f.y);
        if (p.x < -20 || p.y < -20 || p.x > width + 20 || p.y > height + 20) continue;
        const r = 1.2 * zoom;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fillStyle = "hsl(120, 100%, 70%)";
        ctx.fill();
      }
      ctx.restore();

      // бактерии
      ctx.save();
      for (const b of renderBacteria) {
        const p = worldToScreen(b.x, b.y);
        if (p.x < -80 || p.y < -80 || p.x > width + 80 || p.y > height + 80) continue;

        const radius = Math.max(2, b.size * zoom);

        // тело (цвет клана)
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = b.familyColor || "#58a6ff";
        ctx.shadowBlur = radius * 1.5;
        ctx.shadowColor = ctx.fillStyle;
        ctx.fill();
        ctx.shadowBlur = 0;

        // кольцо лидера
        if (b.isLeader) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius + 3, 0, Math.PI * 2);
          ctx.stroke();
        }

        // выделение выбранной бактерии (зелёная рамка)
        if (selectedBacteriumId === b.id) {
          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(46, 160, 67, 0.95)";
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius + 6, 0, Math.PI * 2);
          ctx.stroke();
        }

        // полоска голода
        const barWidth = radius * 2.6;
        const barHeight = 3;
        const barX = p.x - barWidth / 2;
        const barY = p.y - radius - 8;

        ctx.fillStyle = "rgba(80, 80, 80, 0.6)";
        ctx.fillRect(barX, barY, barWidth, barHeight);

        const hungerRatio = Math.max(0, Math.min(1, b.hunger / b.maxHunger));
        ctx.fillStyle = hungerRatio > 0.3 ? "rgba(144, 238, 144, 0.9)" : "rgba(255, 99, 71, 0.95)";
        ctx.fillRect(barX, barY, barWidth * hungerRatio, barHeight);

        // имя над бактерией
        ctx.textAlign = "center";
        ctx.fillStyle = "#ffffff";
        ctx.font = "10px system-ui";
        ctx.fillText(b.name, p.x, barY - 3);

        // подробные таблички, если включено (снизу)
        if (showDetails) {
          const startY = p.y + radius + 25;
          const lineH = 11;

          const ageLabel = formatAgeLabel(b.ageYears);
          ctx.textAlign = "center";
          ctx.font = "9px system-ui";
          ctx.fillStyle = "#e6edf3";
          ctx.fillText(`Клан: ${b.familyName || "нет"}`, p.x, startY);
          ctx.fillText(`Возраст: ${ageLabel}`, p.x, startY + lineH);
          ctx.fillText(`Поколение: ${Math.floor(b.generation)}`, p.x, startY + lineH * 2);
          ctx.fillText(`Размер: ${Math.round(b.sizePoints)}/${b.maxSizePoints}`, p.x, startY + lineH * 3);
          ctx.fillText(`Голод: ${Math.round(b.hunger)}/${b.maxHunger}`, p.x, startY + lineH * 4);
          ctx.fillText(`Детей: ${b.childrenCount}`, p.x, startY + lineH * 5);
          if (b.isLeader) {
            ctx.fillStyle = "#ffa657";
            ctx.fillText(`Лидер колонии`, p.x, startY + lineH * 6);
          }
        }
      }
      ctx.restore();

      requestAnimationFrame(draw);
    }

    function updateLeftHud() {
      const count = bacteriaRaw.length;
      const foodCount = foodRaw.length;

      let maxGeneration = 0;
      let maxAge = 0;
      for (const b of bacteriaRaw) {
        if (b.generation > maxGeneration) maxGeneration = b.generation;
        if (b.ageYears !== undefined && b.ageYears > maxAge) maxAge = b.ageYears;
      }

      const totalBorn = lastStats ? lastStats.totalBorn : 0;
      const totalDied = lastStats ? lastStats.totalDied : 0;

      hudRow1.innerHTML =
        `<span class="label">Бактерий:</span><span class="value">${count}</span>` +
        `<span class="label">Еда:</span><span class="value">${foodCount}</span>` +
        `<span class="label">Мир:</span><span class="value">${world.width}×${world.height}</span>`;

      hudRow2.innerHTML =
        `<span class="label">Родилось:</span><span class="value">${totalBorn}</span>` +
        `<span class="label">Умерло:</span><span class="value">${totalDied}</span>`;

      hudRow3.innerHTML =
        `<span class="label">Макс. поколение:</span><span class="value">${Math.floor(maxGeneration)}</span>` +
        `<span class="label">Макс. возраст:</span><span class="value">${maxAge.toFixed(1)} лет</span>`;
    }

    function updateRightHud() {
      if (!bacteriaRaw || bacteriaRaw.length === 0) {
        leadersListEl.innerHTML = "<div class='leader-info'>Пока нет бактерий</div>";
        return;
      }

      const clanSize = new Map();
      for (const b of bacteriaRaw) {
        const id = b.familyId || 0;
        clanSize.set(id, (clanSize.get(id) || 0) + 1);
      }

      const leaders = [];
      const others = [];
      for (const b of bacteriaRaw) {
        if (b.isLeader) leaders.push(b);
        else others.push(b);
      }

      const byAgeDesc = (a, b) => {
        const aa = a.ageYears || 0;
        const bb = b.ageYears || 0;
        return bb - aa;
      };

      leaders.sort(byAgeDesc);
      others.sort(byAgeDesc);
      const all = leaders.concat(others);

      let html = "";
      let index = 1;
      for (const b of all) {
        const ageLabel = formatAgeLabel(b.ageYears);
        const size = clanSize.get(b.familyId || 0) || 1;
        const leaderMark = b.isLeader ? " ⭐" : "";
        const selectedClass = (selectedBacteriumId === b.id) ? " row-selected" : "";
        html += `<div class="leader-row${selectedClass}" data-id="${b.id}">
          <div class="leader-main">
            <span class="leader-name">${index}. ${b.name}${leaderMark}</span>
            <span class="leader-clan">${b.familyName || ""}</span>
          </div>
          <div class="leader-info">
            Возраст: ${ageLabel} · В клане: ${size}
          </div>
        </div>`;
        index++;
      }

      leadersListEl.innerHTML = html;
    }

    leadersListEl.addEventListener("click", (e) => {
      const row = e.target.closest(".leader-row");
      if (!row) return;
      const idStr = row.getAttribute("data-id");
      const id = parseInt(idStr, 10);
      if (!Number.isFinite(id)) return;

      if (selectedBacteriumId === id) {
        selectedBacteriumId = null;
      } else {
        selectedBacteriumId = id;
      }
      updateRightHud();
    });

    async function fetchState() {
      try {
        const res = await fetch(SERVER_URL + "/state", { cache: "no-cache" });
        const data = await res.json();
        world = data.world || world;
        worldWidth = world.width;
        worldHeight = world.height;

        bacteriaRaw = data.bacteria || [];
        foodRaw = data.food || [];
        lastStats = data.stats || null;

        if (!lastServerOk) {
          lastServerOk = true;
          serverDot.classList.remove("server-bad");
          serverDot.classList.add("server-ok");
        }
        serverStatusText.textContent = "Сервер: работает";

        updateLeftHud();
        updateRightHud();
      } catch (err) {
        lastServerOk = false;
        serverDot.classList.remove("server-ok");
        serverDot.classList.add("server-bad");
        serverStatusText.textContent = "Сервер: нет связи";
      }
    }

    // более частое обновление состояния + сильное сглаживание
    setInterval(fetchState, 120); // чаще обновляем состояние

    // стартуем
    fetchState();
    requestAnimationFrame(draw);
  </script>
</body>
</html>
